const socket = io.connect('https://3ee8-115-99-153-90.ngrok-free.app'); // Replace with your server URL

////////////////////////////////////////////////////////////////////////////////////////

let localStream;
let peerConnection;
const servers = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

// Doctor starts the call
async function startCall() {

  try {
    // Get user's media (video and audio)
    localStream = await navigator.mediaDevices.getUserMedia({
      video: true,
      audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
    });

    if (localStream) {
      document.getElementById('localVideo').srcObject = localStream;

      // Initialize PeerConnection
      peerConnection = new RTCPeerConnection(servers);

      // Add tracks to the peer connection (audio and video)
      localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

      peerConnection.ontrack = (event) => {
        const remoteVideo = document.getElementById('remoteVideo');
        if (!remoteVideo.srcObject) {
          remoteVideo.srcObject = event.streams[0];
          console.log("Received patient's stream");
        }
      };

      // Send audio to secondary model for processing (via socket)
      sendAudioToServer(localStream); // Pass the entire stream

      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          socket.emit('candidate', event.candidate);
        }
      };

      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);
      socket.emit('offer', offer);
      console.log("Offer sent to patient");

    }

  } catch (error) {
    console.error("Error starting call:", error);
  }
}

/// Function to send audio to server for transcription
function sendAudioToServer(localStream) {
  const mediaRecorder = new MediaRecorder(localStream); // Record the entire local stream (audio and video)

  mediaRecorder.ondataavailable = (event) => {
    // Emit the audio data to the server (secondary model processing)
    socket.emit('audioData', event.data);
  };

  mediaRecorder.start(1000);  // Start recording every 1 second

  // Stop the recording after some time (optional)
  setTimeout(() => {
    mediaRecorder.stop();
  }, 15000);
}


// Patient joins the call
async function joinCall() {
  try {
    localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
    document.getElementById('localVideo').srcObject = localStream;

    peerConnection = new RTCPeerConnection(servers);

    localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

    peerConnection.ontrack = (event) => {
      const remoteVideo = document.getElementById('remoteVideo');
      if (!remoteVideo.srcObject) {
        remoteVideo.srcObject = event.streams[0];
        console.log("Received doctor's stream");
      }
    };

    peerConnection.onicecandidate = (event) => {
      if (event.candidate) {
        socket.emit('candidate', event.candidate);
      }
    };
  } catch (error) {
    console.error("Error joining call:", error);
  }
}

// End call functionality
document.addEventListener('DOMContentLoaded', () => {
  const endCallButton = document.getElementById('endCallButtonDoctor');
  if (endCallButton) {
    endCallButton.addEventListener('click', () => {
      closeMediaStreams();
      socket.emit('endCall', { message: 'Call Ended', prescription: "Prescription generated by the secondary model." });
    });
  }
});

function closeMediaStreams() {
  if (localStream) {
    localStream.getTracks().forEach(track => track.stop());
  }
  if (peerConnection) {
    peerConnection.close();
  }
  document.getElementById('localVideo').srcObject = null;
  document.getElementById('remoteVideo').srcObject = null;  
  const endCallModal = document.getElementById('endCallModal');
  if (endCallModal) {
    endCallModal.style.display = 'block';
  }
}

// WebSocket event handlers
socket.on('endCall', closeMediaStreams);
socket.on('offer', async (offer) => {
  try {
    await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
    const answer = await peerConnection.createAnswer();
    await peerConnection.setLocalDescription(answer);
    socket.emit('answer', answer);
  } catch (error) {
    console.error("Error handling offer:", error);
  }
});

socket.on('answer', async (answer) => {
  try {
    if (peerConnection) {
      await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
    }
  } catch (error) {
    console.error("Error handling answer:", error);
  }
});

socket.on('candidate', async (candidate) => {
  try {
    if (peerConnection) {
      await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
    }
  } catch (error) {
    console.error("Error adding ICE candidate:", error);
  }
});
